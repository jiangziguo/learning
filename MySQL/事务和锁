问题：
     -- 为什么MySQL需要锁
     -- 锁的种类及其优缺点
     -- 锁的锁模式有哪些（MyISAM和InnoDB）
     -- 死锁

1. 为什么MySQL需要锁
        锁是计算机协调多个进程或纯线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，
    数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题。锁冲突也是
    影响数据库并发访问性能的一个重要因素。

2. 锁的种类及其优缺点
    --表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    --行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    --页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

3. 锁模式 （MyISAM）
    -- 表级锁锁模式：
        -- 表共享读锁
        -- 表独占写锁
        -- 并发机制（&& -> 可并行，|| -> 串行）：读 && 读 ，读 || 写， 写 || 写
        -- 加锁：MyISAM会自动加锁
            -- SELECT: 读锁
            -- 更新（INSERT/UPDATE/DELETE）: 写锁

4. 锁模式（InnoDB）
    -- 不同点
        -- 支持事务
        -- 引入行级锁
    -- 事务（Transaction）及其ACID属性
        事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。
            -- 原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
            -- 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。
                                     这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；
                                     事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
            -- 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。
                                    这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
            -- 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。
    -- 并发事务带来的问题
        -- 更新丢失（Lost Update）：事务A和B同时更新同一行数据，事务A覆盖了事务B所做的更新。
        -- 脏读（Dirty Reads）：比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
                                当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。
        -- 不可重复读（Non-Repeatable Reads）：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，
                                               然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
                                               针对 update或delete
        -- 幻读（Phantom Reads）：事务A首先根据条件索引得到N条数据，
                                  然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，
                                  导致事务A再次搜索发现有N+M条数据了，就产生了幻读。针对 insert

    -- 事务隔离级别及其副作用
       -- 未提交读（Read uncommitted）：最低级别，其它副作用：111 （读数据一致性，脏读、不可重复读、幻读）
       -- 已提交读（Read committed）：语句级，011
       -- 可重复读（Repeatable read）：事物级，001
       -- 可序列化（Serializable）：最高级别，事务级，000

       ＭySQL支持全部４个隔离级别

    -- InnoDB的锁模式及加锁方法
        - 两种类型的 行锁
            - 共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
            - 排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
        - 两种意向锁 表锁
            - 意向共享锁（IS）：事务在给一个数据行加共享锁前必须先取得该表的IS锁。
            - 意向排他锁（IX）：事务在给一个数据行加排他锁前必须先取得该表的IX锁。
        - 行锁实现方式
            - 只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！
        - 间隙锁（Next-Key锁）
            - 范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，
              也会对empid大于101（这些记录并不存在）的“间隙”加锁。
            - 作用
                - 防止幻读
                - 满足其恢复和复制的需要
        - 表锁
            - 使用条件
                - 事务需要更新大部分或全部数据，表又比较大
                - 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚
            - 注意
                - 表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的
                - 事务结束前，不要用UNLOCAK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务
                - COMMIT或ROLLBACK产不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁
5. 死锁
    - ＭyISAM表锁：是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，不会出现死锁。
    - InnoDB：锁是逐步获得的，就可能产生死锁
        - 解除死锁
            - InnoDB一般都能自动检测到
            - 设置锁等待超时参数innodb_lock_wait_timeout来解决
        - 避免死锁
            - 不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表
            - 程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录
            - 更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁
    如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施