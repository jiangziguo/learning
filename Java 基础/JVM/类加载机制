1. 类加载过程
    - 类生命周期：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
    - 类加载：加载 -> 验证 -> 准备 -> 解析 -> 初始化
              注意：解析可以在初始化之后进行（支持Java运行时绑定），其它阶段按顺序开始，交叉进行
    - 绑定
        - 定义：把一个方法的调用与方法所在的类(方法主体)关联起来
        - 静态绑定：前期绑定，程序执行前已经绑定，java当中的方法只有final，static，private和构造方法是前期绑定的。
        - 动态绑定：运行时绑定，运行时根据对象的类型绑定，几乎所有的方法都是后期绑定

2. 类加载解析
    2.1 加载
        - 通过一个类的全限定名来获取其定义的二进制字节流。（读取class文件）
        - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。（生成运行时数据结构）
        - 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。（生成Class对象）
        扩展话题：类加载器
            - 对于任意一个类，只要加载它们的类加载器不同，那这两个类就必定不相等（equals()/isAssignableFrom()/isInstance()）
            - 3种类加载器
                - 启动类加载器：Bootstrap ClassLoader，加载JDK\jre\lib\ext目录中的类，启动类加载器是无法被Java程序直接引用的。
                - 扩展类加载器：Extension ClassLoader，加载JDK\jre\lib\ext中的类，开发者可以直接使用扩展类加载器。
                - 应用程序类加载器：Application ClassLoader，它负责加载用户类路径（ClassPath）所指定的类，
                                    开发者可以直接使用该类加载器，一般情况下这个就是程序中默认的类加载器。
            - 类加载器的双亲委派模型
                - 模型：自定义类加载器 -> 应用程序类加载器 -> 扩展类加载器 -> 启动类加载器
                - 加载流程：所有的类加载请求最终都被传递到顶层的启动类加载器中，只有当父加载器无法完成该加载，
                            子加载器才会尝试自己去加载该类。
                - 好处：例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，
                        最终都会委派给启动类加载器进行加载，这保证了Object类在程序中的各种类加载器中都是同一个类。
    2.2 验证
        - 文件格式的验证、元数据的验证、字节码验证和符号引用验证。

    2.3 准备
        - 为 类变量 分配内存并设置类变量的初始值，这些内存都将在方法区中分配。
        - 注意：
            - 初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
            - 局部变量 或者 final修饰的常量 或者 被static和final同时修饰的常量（必须在声明的时候就为其显式地赋值），
              必须显示赋值，系统不会为其赋予默认值。
            - 同时被final和static修饰，在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

    2.4 解析
        - 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。
        - 扩展
            - 符号引用：可以理解为占位符
                        符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，
                        只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，
                        引用的目标并不一定已经加载到了内存中。
            - 直接引用：理解为地址
                        直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
                        直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。
                        如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。
        - 解析过程
            - 类或接口的解析
            - 字段解析：本类查找，如果没有找到，先查父接口，然后查父类
            - 类方法解析
            - 接口方法解析

    2.5 初始化
        - 根据程序员通过程序指定的主观计划去初始化类变量和其他资源，执行类构造器<clinit>()方法的过程
        - 注意：
            - <clinit>（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，
              编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，
              定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。
            - 虚拟机会保证在子类的<clinit>（）方法执行之前，父类的<clinit>（）方法已经执行完毕。
            - <clinit>（）方法对于类或接口来说并不是必须的
            - 执行接口的<clinit>（）方法不需要先执行父接口的<clinit>（）方法，只有当父接口中定义的变量被使用时，
              父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>（）方法。
            - <clinit>（）方法是线程安全的，只能有一个线程执行


总结：
        整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。
    到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于<clinit>（）方法。
    类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，
    在加载完成后才真正开始。